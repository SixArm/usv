# ユニコード区切り値 (USV)

ユニコード区切り値 (USV) は、データとデータの間にユニコード文字を配置するデータ形式です。以下のユニコード文字を使用します:

* ␟ = U+241F = US = ユニット区切り。データユニット間、データベースの列、スプレッドシートのセルなどの区切りに使用します。

* ␞ = U+241E = RS = レコード区切り。データレコード間、データベースの行、スプレッドシートの行などの区切りに使用します。

* ␝ = U+241D = GS = グループ区切り。データグループ間、データベースのテーブル、スプレッドシートのグリッドなどの区切りに使用します。

* ␜ = U+241C = FS = ファイル区切り。データファイル間、データベースのスキーマ、スプレッドシートのフォリオなどの区切りに使用します。

カンマ区切り値 (CSV)、タブ区切り値 (TSV)、ASCII区切り値 (ASV) をご存知なら、すでにUSVもご存じでしょう。


## 例

2つのユニットからなるUSV:

```
a␟b
```

2つのレコードと、それぞれ2つのユニットからなるUSV:

```
a␟b␞c␟d
```

2つのグループ、それぞれ2つのレコード、それぞれ2つのユニットからなるUSV:

```
a␟b␞c␟d␝e␟f␞g␟h
```

2つのファイル、それぞれ2つのグループ、それぞれ2つのレコード、それぞれ2つのユニットからなるUSV:

```
a␟b␞c␟d␝e␟f␞g␟h␜i␟j␞k␟l␝m␟n␞o␟p
```


## USVは簡単で親しみやすい

USVは簡単に使用でき、試してみたいと思える親しみやすさを織り込んでいます:

USVでは、さまざまな種類のデータを扱えます。USVに使用する4種類の文字を除き、あらゆる文字をデータに含めることができます。

USVはさまざまなエディターで扱うことができます。USVに使用する文字を表示できるエディタなら、どのエディターでも扱えます。vi、emacs、Coda、Notepad++、TextMate、Sublime、VS Codeなどで実際に利用できます。

USVは多様な種類のツールで動作します。USVに使用する文字をパースできるツールなら、どのツールでも動作します。awk、sed、grep、rg、miller などで実際に使えます。

USVはさまざまな言語で動作します。UTF-8の文字コードとレンダリングを扱える言語であれば、どの言語でも動作するはずです。C、Go、Java、JavaScript、Julia、Python、R、Ruby、Rust、Swift、PHPなどで実際に動作します。


## なぜUSVを使うのか

USVでは、カンマ、タブ、改行などの特殊文字を含むデータを、エスケープせずに扱うことができます。

USVは、ユニット/列/セル、レコード/行/ライン (CSVやTSVと同様) のほか、グループ/テーブル/グリッド、ファイル/スキーマ/フォリオ (ASVと同様) の形式を表現できます。

USVは国際標準を目指しています。

USVは、意味を持つユニコード文字を使用しています。

USVは、典型的なUnicode対応のエディター、典型的なUnicode対応言語、典型的なUnicode対応フォントであれば、良好に機能します。

USVは文字幅を持った目に見える文字を使用してるため、視認、選択、コピー、ペースト、検索が容易です。

USVは、一般的なシェルスクリプト内で問題なく動作します。

USVは、一般的な検索ツールで問題なく動作します。

USVはエスケープ文字がないため、よりシンプルでわかりやすい使い方や書き方ができます。


## 手伝ってくれる人のためのTODOリスト

LibreOffice Calc、Microsoft Excel、Google Sheetsなどの生産性アプリケーションへのUSV形式の追加。

R、Julia、MatLab、Mathematicaなどの統計システムへのUSV処理機能の追加。

Nodeパッケージ、Ruby gem、Rust crateなどの作成など、プログラミング言語へのUSVライブラリの追加。

Miller (対応済み)、TextQL (オープンissueあり)、Q (オープンissueあり)、jqなどのコマンドラインツールへのUSV機能の追加。


## よくある質問

<dl>

<dt>USVは簡単ですか？</dt>

<dd>

<p>はい。カンマ区切り値 (CSV)、タブ区切り値 (TSV)、ASCII区切り値 (ASV) をご存知なら、USVのこともほとんど理解できます。</p>

</dd>

<dt>USVは標準ですか？</dt>

<dd>

<p>その予定です。できる限り早期の標準化を目指しています。</p>

<p>USVはJoel Parker Henderson (joel@joelparkerhenderson.com) が中心となって提案した規格で、<a href="https://www.iana.org/assignments/media-types/text/tab-separated-values">IANA TSV</a>と同様の標準化を目指しています。</p>

</dd>

<dt>CSVやTSVではなくUSVを選ぶメリットは？</dt>

<dd>カンマ、タブ、改行をデータの中で使用することができます。データグループ、データベースのテーブル、スプレッドシートのグリッドをデータの中で示すことができます。データファイル、データベーススキーマ、スプレッドシートのフォリオをデータ形式の中で扱うことができます。CSVでは通常得られない、一貫性と互換性を備えた標準的な形式が必要な場合に適しています。CSV/TSV/TDFでは通常得られない、一貫性と互換性を備えた標準的なファイル拡張子が必要な場合に適しています。</dd>

<dt>ASVではなくUTFを選ぶメリットは？</dt>

<dd>データの中身を人間が読んだり編集したりする時のために、より扱いやすいものにすることができます。USVでは通常目に見える、文字幅を持ったUnicode 241Fなどの文字を使用します。これに対しASVでは、ASCII 31など、通常目に見えないゼロ幅の文字を使用します。エディターのなかには、それらに対応するUSVの可視文字などの視覚表現を使ってASV文字を表示してくれるものもありますが、実際にこの方法がサポートされる例はあまり見られませんでした。</p>

</dd>

<dt>機械のみが使用するデータにASFではなくUTFを選ぶメリットは？</dt>

<dd>人間が読んだり編集したりすることのない、機械のみが使用するデータの場合は、USVとASVのどちらもユニット、フィールド、グループ、ファイルなどが扱えるため、類似しています。

<dt>USVでは特殊文字のエスケープが可能ですか？</dt>

<dd>いいえ。意図的にエスケープを扱わない決断をしました。バックスラッシュ、アンパサンド、引用符、二重文字などで特別なエスケープ処理が行われることはありません。この方針により、USVはより簡単に使用でき、より速くパースでき、より明瞭に標準化することができます。文字エスケープについて調べたところ、エスケープは一部のニーズを解決する一方で、他のニーズに困難を生じさせることがわかりました。現実の英語のテキストではカンマが頻繁に使われるため、CSVのエスケープは非常に重要であるという結論に達しました。USVでは、このようなニーズが頻繁に生じることはありません。</dd>

<dt>特殊文字のエスケープがどうしても必要な場合はどうすればよいですか？</dt>

<dd>どうしても特殊文字のエスケープが必要なことがあります。例えば、USV文字を含むデータコンテンツがあるとします。このような目的のためには、より強力な別のフォーマット (JSONやXMLなど) を使用するか、HTMLのアンパサンドエンコーディング (ユニット区切りは「&us;」など) やUnicodeの「バックスラッシュu」エンコーディング (「\u241F」など) といった、USVを使わない独自の内部エンコーディングを作り出すのがよいかもしれません。</dd>

<dt>USVでは空白文字を特別に扱いますか？</dt>

<dd>いいえ。意図的にそのような処理を行わない決断をしました。スペース、タブ、改行などのホワイトスペースの特別な処理は行いません。この方針により、USVはより簡単に使用でき、より速くパースでき、より明瞭に標準化することができます。空白の処理について調べたところ、空白処理は一部のニーズを解決する一方で、他のニーズに困難を生じさせることがわかりました。それを受けて、ホワイトスペースの処理は利便性を提供する場面があるものの、必須のものではないため、USVの規格からは取り除くという結論に達しました。
</dd>

<dt>ホワイトスペースの特別処理が必要な場合は？</dt>

<dd>どうしてもホワイトスペースの特別処理が必要なことがあります。例えばUSV文字の直前や直後に入れた改行など、データを囲っている空白文字を取り込みたいといったケースです。このような場合、通常のようにUSVを使用し、後から `trim`、`strip`、`chomp` といった関数を呼び出すなどの独自のホワイトスペース処理を入れるとよいでしょう。</dd>

</dl>


## USVのプルリクエスト 

プルリクエストを作成する:

* Q: <https://github.com/harelba/q/issues/201>

* TextQL: https://github.com/dinedal/textql/issues/115

完了したプルリクエスト:

* Miller: <https://github.com/johnkerl/miller/issues/245>


## CSV、TSV、TDF、ASV、DELとの比較

ユニコード区切り値 (USV) は、他のフォーマットと同様の目的を持ったデータフォーマットです。

<dl>

<dt>カンマ区切り値 (CSV)</dt>

<dd>CSV形式では、値の区切りにカンマを、レコードの区切りに改行を使用します。経験上、CSV形式には様々な実装があり、互換性のないもの、エスケープを使用するもの、使用しないものがあります。また、ファイル名の拡張子「.csv」は、タブ、セミコロン、スペースなど、他の文字で区切られたデータであるという意味で使っているソフトウェアもあります。CSVではデータのユニット/列/セル、データのレコード/行/列を扱うことはできますが、データのグループ/表/グリッド、データのファイル/スキーマ/ポートフォリオは扱えません。</dd>

<dt>タブ区切り値 (TSV)、別名タブ区切り形式 (TDF)</dt>

<dd>TSV形式では、値の区切りにタブを、レコードの区切りに改行を使用します。経験上、TSV形式はタブ文字が見えないことや、2スペース、4スペース、8スペース、あるいは次のタブストップが現れるまで任意の数のスペースと等しい可変の文字幅を取るため、エディターによっては編集が困難な場合があるようです。TSVではデータのユニット/列/セル、データのレコード/行/列を扱うことはできますが、データのグループ/表/グリッド、データのファイル/スキーマ/フォリオは扱えません。</dd>

<dt>ASCII区切り値 (ASV)、別名DEL (Delimited ASCII)</dt>

<dd>ASV形式では、ファイル区切りにASCII文字28、グループ区切りに29、レコード区切りに30、ユニット区切りに31を使用します。ASVとUSVはどちらも同様のデータ区切りを行います。経験上、これらのASCII文字は、多くのエディターで目に見えないゼロ幅文字として扱われるため、手動で編集するのが難しいという傾向があります。USVは同じ趣向ですが、文字幅を持った、目に見える文字を使用します。</dd>

</dl>


## スクリプト例

3ユニット×3レコードのUSVファイルのサンプルを作成する:

```
$ echo 'a␟b␟c␞d␟e␟f␞g␟h␟i' > example.usv
```

`sed` を使ってUSVからCSVに変換する:

```sh
$ cat example.usv | sed 's/␟/,/g; s/␞/\n/g;' 
```

`tr` を使ってUSVをTSVに変換する:

```sh
$ cat example.usv | tr ␟␞ ',\n'
```

`awk` を使ってUSVをTSVに変換する:

```sh
$ cat example.usv | awk 'BEGIN { FS="␟"; RS="␞"; OFS=","; ORS="\n"; } {$1=$1}1' | grep -v ^$
```

典型的なシェルコマンドでUSVを表示し、きれいに出力する:

```sh
$ echo "a␟b␞c␟d␝e␟f␞g␟h␜i␟j␞k␟l␝m␟n␞o␟p" | 
  sed 's/␟/,/g; s/␞/\n/g; s/␝/\n---\n/g; s/␜/\n===\n/g;'
a,b
c,d
---
e,f
g,h
===
i,j
k,l
---
m,n
o,p
```


## BNF疑似コード

unit_separator ::= U+241F

record_separator ::= U+241E

group_separator ::= U+241D

file_separator ::= U+241C

unit ::= [character]+  # 4種類の区切り文字を除くすべての文字

units ::= unit ( unit_separator unit ) *

record ::= [units]*

records ::= record ( record_separator record ) *

group ::= [records]*

groups ::= group ( group_separator group ) *

file ::= [groups]*

files ::= file ( file_separator file ) *

usv ::= units or records or groups or files


## ASCII区切り値 (ASV) の歴史

➤ <https://www.lammertbies.nl/comm/info/ascii-characters>

<dl>

<dt>ASCII 28 = FS = ファイル区切り</dt>

<dd>ファイル区切りのFSは、60年代のコンピューター技術がどのように編成されていたかを知る上で興味深い制御コードです。今でこそRAMや磁気ディスクのようなランダムアクセスメディアが広まっていますが、ASCII規格が定義された当時、ほとんどのデータはシリアルでした。シリアル通信だけでなく、パンチカード、紙テープ、磁気テープなど、ストレージもシリアルだったということです。このような状況では、ファイルがそこで分かれることを知らせる制御コードを持っておくと、明らかに効率的です。そのために定義されたのがFSです。</dd>

<dt>ASCII 29 = GS = グループ区切り</dt>

<dd>データを保存するという用途は、いくつかの制御コードがASCIIの定義に組み込まれた主な理由の1つでした。データベースは、複数のレコードを格納した複数のテーブルで構成されることがほとんどです。1つのテーブル内のすべてのレコードは同じ型を持ちますが、異なるテーブルのレコードは異なる型になることがあります。グループ区切りのGSは、シリアルデータストレージシステムでテーブルを分割する目的で定義されました。なお、当時はテーブルという言葉が使われておらず、ASCIIを策定した人たちはグループと呼んでいました。</dd>

<dt>ASCII 30 = RS = レコード区切り</dt>

<dd>グループ (またはテーブル) 内では、レコードがRS (レコード区切り) で区切られます。</dd>

<dt>ASCII 31 = US = ユニット区切り</dt> 

<dd>データベースに格納される最小のデータ項目を、ASCIIの定義では「ユニット」と呼びます。現在では「フィールド」と呼ばれるものです。ユニット区切りは、シリアルデータを保存する環境において、そのようなフィールドを区切ります。現在のデータベース実装では、ほとんどの種類のフィールドが固定長であることが求められます。各フィールドで可能な限り大きなメンバーを格納するため、たとえそれが必要となる場面がほとんどないとしても、レコードには十分なスペースが割り当てられます。このため、多くの場面では大きなスペースが犠牲になります。US制御コードを用いると、すべてのフィールドを可変長にすることができます。60年代のようにデータの保存スペースが限られている場合、これは貴重なスペースを取っておくための優れた方法です。一方で、現代のテーブル駆動のRAMやディスク装置に比べ、シリアルストレージははるかに効率が悪いものでした。現代のSQLデータベースが紙テープや磁気リールに保存されたデータを扱う状況など、想像もつきません。</dd>


## 結論

USVは、実際のデータ形式プロジェクトでも役立っています。皆さんにもUSVがお役に立てればと思っています。

USVに関する建設的なフィードバックや、git issue、pull request、標準化に関するお手伝いを歓迎します。
